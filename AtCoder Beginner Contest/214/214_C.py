"""
O(N^2) 풀이: i(1<=i<=N)번에 대해서 T[i]와 그때 S를 순회하며 gem을 얻는 시간을 구하여 최소값 갱신

하지만 i번은 i+1번에게 주므로 N^2번을 모두 볼 필요는 없음
예컨대, 1 1 1// 1 100 100 이라면 답은 1 2 3이 될 것
즉 O(N)만에 풀 수 있음

이때 주의할 점은 맨끝에서 앞으로 다시 갱신을 할 필요가 있다는 점이다.
이는 2N번 순회하는 것으로 해결 가능하며, 예시는 다음과 같다.
6
1 1 1 1 1 1
10 15 15 15 1 15

최소값을 갱신하는 과정에서 T를 출력하면서 확인하면 더 쉽게 이해할 수 있다.
"""
N = int(input())
S = list(map(int, input().split()))
T = list(map(int, input().split()))

for i in range(N*2):
    T[(i+1)%N] = min(T[(i+1)%N], T[i%N] + S[i%N])

for ans in T:
    print(ans)
